<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/0.3.24/peerjs.min.js"></script>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SyncFiddle</title>
  <style>
    body {
      font-family: "Helvetica Neue", Helvetica, sans-serif;
    }

  	pre.train {
    	position: absolute;
      right: -1000px;
      bottom: 0px;
      min-width: 600px;
    }
  </style>
</head>
<body style="overflow:hidden; color: #fff; background-color: #000;">
  <div>
    <div id="myId" style="display: inline-block; ">Connecting...</div><button id="copy" style="display: none; margin-left: 4px; " onclick="copyToClipboard()">Copy</button><br />
    </div>
    <div id="masterArea">
    <button id="btnBecomeMaster">Become Master</button>
      <div id="slaveList">
      Wanna become the master?
      </div>
      <button id="btnConnectAllPeers" style="display: none;">Connect all Peers</button>

      <input id="inPeerOutgoing" placeholder="peer on your left" type="text"/>
      <button id="btnConnect">Connect</button>
    </div>
    <div id="status"></div>
    <img style="display: none; vertical-align: middle; margin-left: 4px; width: 16px; height: 16px; " id="connect.success" src="https://cdn3.iconfinder.com/data/icons/flat-actions-icons-9/512/Tick_Mark-256.png">
    <img style="display: none; vertical-align: middle; margin-left: 4px; width: 16px; height: 16px; " id="connect.error" src="https://cdn3.iconfinder.com/data/icons/flat-actions-icons-9/792/Close_Icon-256.png">
  <br/>
  <button id="btnStart">Start train!</button>


  <div id="track"></div>
  <script type="text/javascript">
    var copyToClipboard;
    
    (() => {
      // See the console window at bottom.
      var keyFrames = [
				"                                      (@@@)            \n" +
				"                                        (@@@@@@@)                 \n" +
				"                                                  (@@@@@@@@@@@)\n" +
				"                    (@@@)                                           \n" +
				"                           (@@@@@@)                   \n" +
				"                                   (@@)\n" +
				"        (@@)                   \n" +
				"       .-.               \n" +
				"       ] [    .-.      _    .-----.\n" +
				"     .\"   \"\"\"\"   \"\"\"\"\"\" \"\"\"\"| .--`\n" +
				"    (:--:--:--:--:--:--:--:-| [___    .------------------------.\n" +
				"     |C&O  :  :  :  :  :  : [_9_] |'='|.----------------------.|\n" +
				"    /|.___________________________|___|'--.___.--.___.--.___.-'| \n" +
				"   / ||_.--.______.--.______.--._ |---\\'--\\-.-/==\\-.-/==\\-.-/-'/--\n" +
				"  /__;^=(‾‾)‾‾‾‾‾‾(‾‾)‾‾‾‾‾‾(‾‾)=^~^^^ ^^^^(-)^^^^(-)^^^^(-)^^^ jgs\n" +
				"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
        "                                                (@@@@@)\n" +
        "                                                         (@@@@@@@)\n" +
        "                         (@@@@@@@)                             \n" +
        "                              (@@@@@@@)                        (@@@)\n" +
        "                                                     \n" +
        "           (@@@)                       \n" +
        "                          (@@@)\n" +
        "       .-.               \n" +
        "       ] [    .-.      _    .-----.\n" +
        "     .\"   \"\"\"\"   \"\"\"\"\"\" \"\"\"\"| .--`\n" +
        "    (:--:--:--:--:--:--:--:-| [___    .------------------------.\n" +
        "     |C&O  :  :  :  :  :  : [_9_] |'='|.----------------------.|\n" +
        "    /|.___________________________|___|'--.___.--.___.--.___.-'| \n" +
        "   / ||_.--.______.--.______.--._ |---\\'--\\-.-/==\\-.-/==\\-.-/-'/--\n" +
        "  /__;^=(--)------(--)------(--)=^~^^^ ^^^^(-)^^^^(-)^^^^(-)^^^ jgs\n" +
        "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
        "                               (@@)                              \n" +
				"                                     (@@@@@)                    \n" +
				"                                          (@@@@@@)                  \n" +
				"               (@@@@@@)                            (@)\n" +
				"                  (@@@@)               \n" +
				"                          (@@@)\n" +
				"       .-.               \n" +
				"       ] [    .-.      _    .-----.\n" +
				"     .\"   \"\"\"\"   \"\"\"\"\"\" \"\"\"\"| .--`\n" +
				"    (:--:--:--:--:--:--:--:-| [___    .------------------------.\n" +
				"     |C&O  :  :  :  :  :  : [_9_] |'='|.----------------------.|\n" +
				"    /|.___________________________|___|'--.___.--.___.--.___.-'| \n" +
				"   / ||_.--.______.--.______.--._ |---\\'--\\-.-/==\\-.-/==\\-.-/-'/--\n" +
				"  /__;^=(__)______(__)______(__)=^~^^^ ^^^^(-)^^^^(-)^^^^(-)^^^ jgs    \n" +
				"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"];
      
      var KEY_DEL = 46;
      var MESSAGE_START_TRAIN = 'train.start';
      var OFFSET_INCREMENT = 10;
      var ANIMATION_INTERVAL = 50;
      var peer = new Peer({debug: true});
      var connIn, connOut;
      var copyElement = document.getElementById('copy');
      
      var connectSuccessElement = document.getElementById('connect.success');
      var connectErrorElement = document.getElementById('connect.error');
      var trackElement = document.getElementById('track');
      var hoveredTrain;
      var hoveredInterval;
      
      peer.on('error', (error) => {
        if(error.type == 'peer-unavailable') {
          connectSuccessElement.style.display = 'none';
        	connectErrorElement.style.display = 'inline';
        }
      });

      function startTrain() {
        var trainElement = document.createElement('pre');
        trainElement.classList.add('train');
        trackElement.appendChild(trainElement);
        var trainStartX = -trainElement.getBoundingClientRect().width;
        var offsetX = 0;
        var clientWidth = Math.min(document.body.clientWidth, window.innerWidth);
        var trainSignalled = false;
        var keyframeCounter = 0;

        var interval = setInterval(function() {
          offsetX += OFFSET_INCREMENT;
          var trainPositionX = trainStartX + offsetX;
          drawTrain(trainPositionX);

          if (trainPositionX > clientWidth) {
            console.log("Ending animation.");
            clearInterval(interval);
            interval = null;
            trackElement.removeChild(trainElement);
          } else if (offsetX > clientWidth) {
            signalNextTrainStart();
          }
        }, ANIMATION_INTERVAL);
        
        trainElement.onmouseover = function()  {
          hoveredTrain = this;
          hoveredInterval = interval;
        };
        
        function drawTrain(xCoord) {
          trainElement.style.right = xCoord;
          drawKeyFrameContent();
        }

        function drawKeyFrameContent() {
          var previousKeyFrameIndex = Math.max((keyframeCounter - 1) % keyFrames.length, 0);
          var currentKeyFrameIndex = keyframeCounter % keyFrames.length;

          trainElement.textContent = keyFrames[previousKeyFrameIndex];

          keyframeCounter++;
        }
        
        function signalNextTrainStart() {
          if(!trainSignalled) {
            trainSignalled = true;
            if(!connOut) {
              console.warn('No remote client connected.');
              return;
            }
            console.log("Starting next train.");
            connOut.send(MESSAGE_START_TRAIN);
          }
        }
        
      }

      document.getElementById("btnStart").addEventListener("click", function(){
        startTrain();
      });

      document.getElementById("btnConnect").addEventListener("click", function(){
        var targetId = document.getElementById("inPeerOutgoing").value;
        connect(targetId);
      });

      document.getElementById("btnBecomeMaster").addEventListener("click", becomeMaster);
      document.getElementById("btnConnectAllPeers").addEventListener("click", sendConnectionCommands);

      
      document.onkeydown = function() {
          var key = event.keyCode || event.charCode;

          if(key == KEY_DEL && hoveredTrain) {
            hoveredTrain.parentNode.removeChild(hoveredTrain);
            hoveredTrain = null;
            clearInterval(hoveredInterval);
            return false;
          }
      };

      peer.on('open', function(id) {
        console.log(id);
        document.getElementById('myId').innerHTML = 'Your ID: ' + id;
        copyToClipboard = copyToClipboardRaw.bind(null, id);
        copyElement.style.display = 'inline';
      });

      /**
       * Starts receiving remote notifications from peers
       */
      function receive() {
        peer.on('connection', function(conn) {
          conn.on('data', function(data) {
            if(data == MESSAGE_START_TRAIN) {
              startTrain();
            } else console.warn('I am being spammed: ', data);
          });
        });
      }

      /**
       * Connect to peer with specified id
       *
       * @param id Id of remote peer
       */
      function connect(id) {
        if(!connOut) {
          connOut = peer.connect(id);
          connOut.on('open', function(){
            console.log('Remote client connected: ', id);
            connectErrorElement.style.display = 'none';
            connectSuccessElement.style.display = 'inline';
          });
          connOut.on('error)', () => {
            connectSuccessElement.style.display = 'none';
            connectErrorElement.style.display = 'inline';
          });
          connOut.on('close', () => {
            connectSuccessElement.style.display = 'none';
            connectErrorElement.style.display = 'inline';
          });
        } else closeAndConnect(id);
      }

      /**
       * Closes the current outgoing connection and connects to the specified peer
       *
       * @param id Id of new remote peer
       */
      function closeAndConnect(id) {
        connOut.on('close', () => {
            connOut = null;
            console.log('Remote client disconnected: ', id);
            connect(id);
          });
        connOut.close();
      }
      
      /**
       * Copies the specified string to the local clipboard
       *
       * @param str String to copy
       */
      function copyToClipboardRaw(str) {
        const el = document.createElement('textarea');
        el.value = str;
        el.setAttribute('readonly', '');
        el.style.position = 'absolute';
        el.style.left = '-9999px';
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
      }


      function connectToMaster(masterId) {
          var connToMaster = peer.connect(masterId);
          connToMaster.on('open', function(){
            console.log('connected to master: ', masterId);
            connToMaster.send({type: "SYN"})
          });
          connToMaster.on('error)', () => {
            console.error("could not connect to master");
          });
          connToMaster.on('close', () => {

          });
          connToMaster.on('data', (data) =>{
            if (data.type === "SYN") {
              console.error("wrong command received");
            } else if (data.type === "CON") {
              console.log("Received connection command to", data.target);
              connect(data.target);
            }
        });
      }

      var masterConnections = [];

      function refreshSlaveList() {
        console.log(masterConnections);
        var listElement = document.getElementById("slaveList");
        var inHtml = "";
        masterConnections.forEach((item)=> {
          inHtml += item.peer +"</br>";
        })
        listElement.innerHTML = inHtml;
      }

      function becomeMaster() {
        //probably wait for on open
        console.log("master", peer.id);
        var masterUrl = window.location.href  + "?master=" + peer.id
        document.getElementById('myId').innerHTML = masterUrl;
        copyToClipboard = copyToClipboardRaw.bind(null, masterUrl);
        copyElement.style.display = 'inline';
        document.getElementById("btnConnectAllPeers").style.display = "block";
        document.getElementById("slaveList").innerHTML = "Waiting for peers, let the one to your left open the url next";

        //startup listening server
        peer.on('connection', (conn) => {
          console.log(conn.peer);
        conn.on('data', (data) =>{
          console.log(data);

          if (data.type === "SYN") {
            console.log("Slave connected", conn.peer)
            masterConnections.push(conn);
            refreshSlaveList();
          } else if (data.type === "CON") {
            console.log("Received connection command to", data.target);
          }
        });
});
      }

      function sendConnectionCommands() {
        console.log("sending connect command");
        //create the ring topology
        for (var i = 0; i < masterConnections.length - 1; i++) {
          masterConnections[i].send({type: "CON", target: masterConnections[i+1].peer});
          console.log("send", masterConnections[i], "to connect to ", masterConnections[i+1].peer);

        }

        //connect last with master
        masterConnections[masterConnections.length -1].send({type: "CON", target: peer.id});

        //connect first (master) with first one in list
        connect(masterConnections[0].peer);
      }

      //starup check for masterId in url
      var currentUrl = new URL(window.location.href);
      console.log(currentUrl)
      var masterId = currentUrl.searchParams.get("master");
      if (masterId) {
        document.getElementById("masterArea").style.display = "none";
        document.getElementById("status").innerHTML = "Please wait for master to Start";

        connectToMaster(masterId);
      }

      receive();
    })();
  </script>
</body>
</html>
