<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/0.3.24/peerjs.min.js"></script>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>TschutTschut</title>
  <style>
    body {
      font-family: "Helvetica Neue", Helvetica, sans-serif;
    }

  	pre.floater {
    	position: absolute;
      bottom: 0px;
      min-width: 600px;
      margin: 0;
      padding: 0;
      animation-name: floater;
      animation-duration: 10s;
      animation-timing-function: linear;
    }

    @keyframes floater {
      from { left: 100% }
      to { left: -100% }
    }
  </style>
</head>
<body style="overflow:hidden; color: #fff; background-color: #000; ">
  <div>
    <div id="myId" style="display: inline-block; ">Connecting...</div><button id="copy" style="display: none; margin-left: 4px; " onclick="copyToClipboard()">Copy</button><br />
    </div>
    <div id="masterArea">
    <button id="btnBecomeMaster">Become Master</button>
      <div id="slaveList">
      Wanna become the master?
      </div>
      <button id="btnConnectAllPeers" style="display: none;">Connect all Peers</button>

      <input id="inPeerOutgoing" placeholder="peer on your left" type="text"/>
      <button id="btnConnect">Connect</button>
    </div>
    <div id="status"></div>
    <img style="display: none; vertical-align: middle; margin-left: 4px; width: 16px; height: 16px; " id="connect.success" src="https://cdn3.iconfinder.com/data/icons/flat-actions-icons-9/512/Tick_Mark-256.png">
    <img style="display: none; vertical-align: middle; margin-left: 4px; width: 16px; height: 16px; " id="connect.error" src="https://cdn3.iconfinder.com/data/icons/flat-actions-icons-9/792/Close_Icon-256.png">
  <br/>
  <button id="btnStart">Start train!</button>


  <div id="track"></div>
  <script type="text/javascript">
    var copyToClipboard;
    
    (() => {
      'use strict';

      // See the console window at bottom.
      let TRAIN_KEY_FRAMES = [
				"                                      (@@@)            \n" +
				"                                        (@@@@@@@)                 \n" +
				"                                                  (@@@@@@@@@@@)\n" +
				"                    (@@@)                                           \n" +
				"                           (@@@@@@)                   \n" +
				"                                   (@@)\n" +
				"        (@@)                   \n" +
				"       .-.               \n" +
				"       ] [    .-.      _    .-----.\n" +
				"     .\"   \"\"\"\"   \"\"\"\"\"\" \"\"\"\"| .--`\n" +
				"    (:--:--:--:--:--:--:--:-| [___    .------------------------.\n" +
				"     |C&O  :  :  :  :  :  : [_9_] |'='|.----------------------.|\n" +
				"    /|.___________________________|___|'--.___.--.___.--.___.-'| \n" +
				"   / ||_.--.______.--.______.--._ |---\\'--\\-.-/==\\-.-/==\\-.-/-'/--\n" +
				"  /__;^=(‾‾)‾‾‾‾‾‾(‾‾)‾‾‾‾‾‾(‾‾)=^~^^^ ^^^^(-)^^^^(-)^^^^(-)^^^ jgs\n" +
				"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
        "                                                (@@@@@)\n" +
        "                                                         (@@@@@@@)\n" +
        "                         (@@@@@@@)                             \n" +
        "                              (@@@@@@@)                        (@@@)\n" +
        "                                                     \n" +
        "           (@@@)                       \n" +
        "                          (@@@)\n" +
        "       .-.               \n" +
        "       ] [    .-.      _    .-----.\n" +
        "     .\"   \"\"\"\"   \"\"\"\"\"\" \"\"\"\"| .--`\n" +
        "    (:--:--:--:--:--:--:--:-| [___    .------------------------.\n" +
        "     |C&O  :  :  :  :  :  : [_9_] |'='|.----------------------.|\n" +
        "    /|.___________________________|___|'--.___.--.___.--.___.-'| \n" +
        "   / ||_.--.______.--.______.--._ |---\\'--\\-.-/==\\-.-/==\\-.-/-'/--\n" +
        "  /__;^=(--)------(--)------(--)=^~^^^ ^^^^(-)^^^^(-)^^^^(-)^^^ jgs\n" +
        "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
        "                               (@@)                              \n" +
				"                                     (@@@@@)                    \n" +
				"                                          (@@@@@@)                  \n" +
				"               (@@@@@@)                            (@)\n" +
				"                  (@@@@)               \n" +
				"                          (@@@)\n" +
				"       .-.               \n" +
				"       ] [    .-.      _    .-----.\n" +
				"     .\"   \"\"\"\"   \"\"\"\"\"\" \"\"\"\"| .--`\n" +
				"    (:--:--:--:--:--:--:--:-| [___    .------------------------.\n" +
				"     |C&O  :  :  :  :  :  : [_9_] |'='|.----------------------.|\n" +
				"    /|.___________________________|___|'--.___.--.___.--.___.-'| \n" +
				"   / ||_.--.______.--.______.--._ |---\\'--\\-.-/==\\-.-/==\\-.-/-'/--\n" +
				"  /__;^=(__)______(__)______(__)=^~^^^ ^^^^(-)^^^^(-)^^^^(-)^^^ jgs    \n" +
				"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"];
      
      var keyFrames = TRAIN_KEY_FRAMES;

      const KEY_DEL = 46;
      const MESSAGE_START_TRAIN = 'train.start';
      const MESSAGE_SYNC = 'SYN';
      const MESSAGE_CONNECT = 'CON';
      const OFFSET_INCREMENT = 10;
      const ANIMATION_INTERVAL = 40;
      const ANIMATION_DURATION_MILLIS = 10000;
      const MAX_FRAME_COUNT = ANIMATION_DURATION_MILLIS/ANIMATION_INTERVAL - 1;

      let peer = new Peer({debug: true});
      var connIn, connOut;
      var copyButton = document.getElementById('copy');
       
      var connectSuccessElement = document.getElementById('connect.success');
      var connectErrorElement = document.getElementById('connect.error');
      var trackElement = document.getElementById('track');
      var hoveredTrain;
      var hoveredInterval;
      
      peer.on('error', (error) => {
        if(error.type == 'peer-unavailable') {
          connectSuccessElement.style.display = 'none';
        	connectErrorElement.style.display = 'inline';
        }
      });

      class Floater {
        constructor(keyFrames) {
          this.keyFrames = keyFrames || TRAIN_KEY_FRAMES;
          this.element = document.createElement('pre');
          this.element.classList.add('floater');
          this.element.textContent = this.keyFrames[0];
          this.endSignalled = false;
          this.interval = null;
          this.frameCounter = 0;

          this.element.onmouseover = function()  {
            hoveredTrain = this;
            hoveredInterval = interval;
          };
        }

        start() {
          track.appendChild(this.element);
          this.interval = setInterval(this.update.bind(this), ANIMATION_INTERVAL);
        }

        update() {
          this.updateKeyFrame();

          if(this.element.offsetLeft <= 0) {
            this.signalNextTrainStart();
          }

          if(this.frameCounter >= MAX_FRAME_COUNT) {
            console.log("Floater expiring.");
            clearInterval(this.interval);
            this.interval = null;
            trackElement.removeChild(this.element);
          }

          this.frameCounter++;
        }

        updateKeyFrame() {
          this.element.textContent = this.keyFrames[this.currentKeyFrameIndex];
        }

        get currentKeyFrameIndex() {
          return this.frameCounter % this.keyFrames.length;
        }

        signalNextTrainStart() {
          if(!this.trainSignalled) {
            this.trainSignalled = true;
            if(!connOut) {
              console.warn('No remote client connected.');
              return;
            }
            console.log("Starting next train.");
            connOut.send(MESSAGE_START_TRAIN);
          }
        }

      }

      function startFloater() {
        new Floater().start();
      }

      document.getElementById("btnStart").addEventListener("click", function(){
        startFloater();
      });

      document.getElementById("btnConnect").addEventListener("click", function(){
        var targetId = document.getElementById("inPeerOutgoing").value;
        connect(targetId);
      });

      document.getElementById("btnBecomeMaster").addEventListener("click", becomeMaster);
      document.getElementById("btnConnectAllPeers").addEventListener("click", sendConnectionCommands);

      
      document.onkeydown = function() {
          var key = event.keyCode || event.charCode;

          if(key == KEY_DEL && hoveredTrain) {
            hoveredTrain.parentNode.removeChild(hoveredTrain);
            hoveredTrain = null;
            clearInterval(hoveredInterval);
            return false;
          }
      };

      peer.on('open', function(id) {
        console.log(id);
        document.getElementById('myId').innerHTML = 'Your ID: ' + id;
        copyToClipboard = copyToClipboardRaw.bind(null, id);
        copyButton.style.display = 'inline';
      });

      /**
       * Starts receiving remote notifications from peers
       */
      function receive() {
        peer.on('connection', function(conn) {
          conn.on('data', function(data) {
            if(data == MESSAGE_START_TRAIN) {
              startFloater();
            } else console.warn('I am being spammed: ', data);
          });
        });
      }

      /**
       * Connect to peer with specified id
       *
       * @param id Id of remote peer
       */
      function connect(id) {
        if(!connOut) {
          connOut = peer.connect(id);
          connOut.on('open', function(){
            console.log('Remote client connected: ', id);
            connectErrorElement.style.display = 'none';
            connectSuccessElement.style.display = 'inline';
          });
          connOut.on('error)', () => {
            connectSuccessElement.style.display = 'none';
            connectErrorElement.style.display = 'inline';
          });
          connOut.on('close', () => {
            connectSuccessElement.style.display = 'none';
            connectErrorElement.style.display = 'inline';
          });
        } else closeAndConnect(id);
      }

      /**
       * Closes the current outgoing connection and connects to the specified peer
       *
       * @param id Id of new remote peer
       */
      function closeAndConnect(id) {
        connOut.on('close', () => {
            connOut = null;
            console.log('Remote client disconnected: ', id);
            connect(id);
          });
        connOut.close();
      }
      
      /**
       * Copies the specified string to the local clipboard
       *
       * @param str String to copy
       */
      function copyToClipboardRaw(str) {
        const el = document.createElement('textarea');
        el.value = str;
        el.setAttribute('readonly', '');
        el.style.position = 'absolute';
        el.style.left = '-9999px';
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
      }


      function connectToMaster(masterId) {
          var connToMaster = peer.connect(masterId);
          connToMaster.on('open', function(){
            console.log('connected to master: ', masterId);
            connToMaster.send({type: MESSAGE_SYNC})
          });
          connToMaster.on('error)', () => {
            console.error("could not connect to master");
          });
          connToMaster.on('close', () => {

          });
          connToMaster.on('data', (data) => {
            if (data.type === MESSAGE_SYNC) {
              console.error("wrong command received");
            } else if (data.type === MESSAGE_CONNECT) {
              console.log("Received connection command to", data.target);
              connect(data.target);
            }
        });
      }

      var masterConnections = [];

      function refreshSlaveList() {
        console.log(masterConnections);
        var listElement = document.getElementById("slaveList");
        var inHtml = "";
        masterConnections.forEach((item)=> {
          inHtml += item.peer +"</br>";
        })
        listElement.innerHTML = inHtml;
      }

      function becomeMaster() {
        //probably wait for on open
        console.log("master", peer.id);
        var masterUrl = window.location.href  + "?master=" + peer.id
        document.getElementById('myId').innerHTML = masterUrl;
        copyToClipboard = copyToClipboardRaw.bind(null, masterUrl);
        copyButton.style.display = 'inline';
        document.getElementById("btnConnectAllPeers").style.display = "block";
        document.getElementById("slaveList").innerHTML = "Waiting for peers, let the one to your left open the url next";

        //startup listening server
        peer.on('connection', (conn) => {
          console.log(conn.peer);
          conn.on('data', (data) =>{
            console.log(data);

            if (data.type === "SYN") {
              console.log("Slave connected", conn.peer)
              masterConnections.push(conn);
              refreshSlaveList();
            } else if (data.type === "CON") {
              console.log("Received connection command to", data.target);
            }
          });
        });
      }

      function sendConnectionCommands() {
        console.log("sending connect command");
        //create the ring topology
        for (var i = 0; i < masterConnections.length - 1; i++) {
          masterConnections[i].send({type: "CON", target: masterConnections[i+1].peer});
          console.log("send", masterConnections[i], "to connect to ", masterConnections[i+1].peer);

        }

        //connect last with master
        masterConnections[masterConnections.length -1].send({type: "CON", target: peer.id});

        //connect first (master) with first one in list
        connect(masterConnections[0].peer);
      }

      //starup check for masterId in url
      var currentUrl = new URL(window.location.href);
      console.log(currentUrl)
      var masterId = currentUrl.searchParams.get("master");
      if (masterId) {
        document.getElementById("masterArea").style.display = "none";
        document.getElementById("status").innerHTML = "Please wait for master to Start";

        connectToMaster(masterId);
      }

      receive();
    })();
  </script>
</body>
</html>
